\chapter{Future Work}

This chapter outlines major tasks that remain towards enhancing the capabilities
of our system.

\section{Soundness of Model Checking Abstraction}\label{sec:abstraction-soundness}

In \autoref{sec:formal-analysis}, we introduced an abstraction that enabled us
to model check the system. Instead of interpreting $\MediK{}$ programs
concretely, we introduced rules that operate over abstract values
that hold semantic meaning. However, we did not establish that the analysis is
indeed sound. In this section, we briefly outline the steps to prove the
soundness of our abstraction-based analysis, and outline limitations that
prevented us from establishing it.

Recall that in \autoref{sec:theoretical-foundations}, we presented the
matching logic: the theoretical foundations of the $\K$ framework. We explained
that a $\K$ definition of a language $L$, compiles to a matching logic theory
$\Gamma^L$. A symbol $\snext \in \Sigma$ is then defined as a part of the
signature to capture dynamic behavior of rewrite rules.
Intuitively, given a configuration
pattern $\gamma$, the pattern $\snext \gamma$ matches all possible
configurations that $\gamma$ can rewrite to in one-step. Thus
the one-step rewrite relation can be defined as:
$$
  \varphi \To^1 \psi \equiv \varphi \to \snext \psi
$$

Next, the reflexive, transitive closure of the one-step rewrite relation
can be defined using fixed-points as:
$$
  \eventually \varphi \equiv \mu X \ldot \varphi \vee \snext X
$$
and the rewrite $\varphi \To \psi$ as:
$$
  \varphi \To \psi \equiv \varphi \to \eventually \psi
$$
In other words, if a configuration matches
$\varphi$ then it matches $\varphi$ in zero or more steps.
Note that the existence of a fixed point of $\eventually\varphi$
is guaranteed by the Knaster-Tarski theorem as long as the interpretation
$\mathcal{F}^{\rho}_{X,\varphi} = \interpret{\varphi}{\rho\left[A / X\right]}$
is monotone \cite{ChenLICS19}.

Typically, establishing soundness of abstraction-based static analysis
requires coming up partial order over abstract states,
$\left(\Abs, \sqsubseteq\right)$, and, semantic rules defined over $\Abs$.
For $a_1, a_2 \in \Abs$, $a_1 \sqsubseteq a_2$ typically means $a_1$ is
\emph{more precise} than $a_2$. Recall that in \autoref{sec:formal-analysis},
that we defined a value \inlinek{#nondet}, denoting the very simple abstract
domain $\top$ or \emph{undetermined},
and rules that operate over it. Let $\ToAbs$ be the transition
system defined by rules over the abstract state. We first need to
establish that for any $a_1, a_2 \in \Abs$, if $a_1 \ToAbs a_2$ then $a_1
\sqsubseteq a_2$. In other words, we need to show that the transition relation
$\ToAbs$ is monotonic w.r.t. the ordering $\sqsubseteq$.

Next, we need to relate the concrete transition system $\To$ to $\ToAbs$.
Typically, this is done by defining a homomorphism $\beta: \Concrete \to \Abstract$
from the set of concrete values $\Concrete$ to the set of abstract values
$\Abstract$. We can then utilize $\beta$ to define a complete lattice
configuration terms. Recall from \autoref{sec:configuration} that
$\MediK{}$'s configuration comprises of an \inlinek{<store>}-cell that
stores map $\rho$ of pointer-value bindings.
Given configuration terms $\overline{\tau}_1, \overline{\tau}_2 \in
\Abs$ with \inlinek{<store>} cells containing maps $\rho_{\overline{\tau}_1}$ and
$\rho_{\overline{\tau}_2}$ respectively.
We say $\overline{\tau}_1 \sqsubseteq \overline{\tau}_2$ iff
they only differ in their
\inlinek{<store>} cell (all other cells are similar), and, for every
pointer in $p \in$ \inlinekmath{keys($\rho_{\overline{\tau}_1} \cup \rho_{\overline{\tau}_2}$)}
we have $\rho_{\overline{\tau}_1}[p] \sqsubseteq \rho_{\overline{\tau}_2}[p]$. Note we
say, given a map $\rho$ of pointer-value bindings,
$\rho[p] = \bot$ for any $p \not\in$ \inlinekmath{keys($\rho$)}.

To complete the soundness argument, we need to need to make the complete the connection
between concrete and abstract executions. Given homomorphism $\beta: \Concrete \to \Abstract$
from concrete values to abstract values, and a concrete configuration term
$\tau$. We derive an abstract configuration term $\overline{\beta}\left(\tau\right)$ from $\tau$ s.t.
every \inlinekmath{$($pointer $\ \mapsto\ $ value$)$} pair in $\tau$'s
\inlinek{<store>}-cell is mapped to \inlinekmath{$($pointer $\ \mapsto\ \beta($value$))$}
in $\overline{\beta}\left(\tau\right)$'s \inlinek{<store>}-cell.
We then need to show that for
concrete terms $\tau, \tau'$ and abstract term $\overline{\tau}$, if
\begin{enumerate*}[label=(\alph*)]
  \item $\tau \To \tau'$, and,
  \item $\overline{\beta}\left(\tau\right) \sqsubseteq \overline{\tau}$
\end{enumerate*}
then there exists an abstract state $\overline{\tau}'$ such that
$\overline{\tau} \ToAbs \overline{\tau}'$ and $\overline{\beta}\left(\tau'\right) \sqsubseteq \overline{\tau}'$.
This, along with the proof of monotonicity of $\ToAbs$ w.r.t. the ordering
$\sqsubseteq$ enables us to show that any trace in the concrete semantics is safely approximated
by a corresponding trace in the abstract semantics, as shown in
\cite{SchmidtLISP98}. However, while we briefly sketch out a proof outline
in this work, a complete proof for a language as complex as \MediK{} is a
significant undertaking, which we leave to future work.

Note that instead of replacing a concrete value with a corresponding abstract value,
we could have simply used a logical variable and symbolic execution to explore
possible interleavings. This would have allowed us to
\begin{enumerate*}
  \item use satisfiability modulo theory (\SMT{}) solvers to eliminate
  non-reachable branches, and,
  \item eliminate the need to develop an maintain an abstract semantics, as
  existing rules would work for both concrete and symbolic execution.
\end{enumerate*}

$\K$ has multiple backends, including a fast execution LLVM backend
that can only handle \emph{ground} patterns, i.e. patterns with logical
variables, and a haskell backend that can handle ML patterns in their
full generality \cite{KFrameworkBackendsUrl}. Symbolic execution requires the use of $\K$'s haskell
backend, which presented signficant performance related challenges when
handling $\MediK{}$ programs as large as the pediatric sepsis management
guidelines presented in our work. Our abstraction-based model checking was in part motivated by
said performance issues. We leave moving to symbolic execution based
program analysis as part of future work.

%Say $\varphi, \psi$ are $\K{}$ $\K$ configuration
%terms, i.e., terms  of the form \inlinekmath{<k> .. </k> <store> ... </store> ...}.






%
%
%containing axioms of the form $\varphi \to \snext\psi$ that
%encode rewrite rules $\varphi \To \psi$, where $\eventually\psi \equiv \mu X \ldot
%\psi \vee \snext X$. The symbol $\snext \in \Sigma$, referred to as the
%\say{one-path next}, defines a transition $\ToExec$ system as follows:

