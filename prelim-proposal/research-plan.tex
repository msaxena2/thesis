\section{Research Plan}

In this section, we discuss challenges we plan to address through this work.

\paragraph{Semantics Based Control Flow Graphs Generation}

Extremely vital to the success of \MediK{}, the the ability
to generate visual representation of \MediK{} programs to aid
comprehensibility to medical domain experts, enabling them to verify
accuracy of encoded medical knowledge. Even though \MediK{} code
structurally resembles paper-based guidelines, said
representations aid comprehensibility for medical
domain experts as the representations resemble their paper-based counterparts,
imparting a sense of familiarity.

Control Flow Graphs (CFGs) form the basis of not only such visual
representations, but other important analyses. For example,
flow-sensitive analyzers can be used to verify that a medical procedure
is performed on both treatment branches.
\CGSs{} form use in applications from compilers to model checkers.
But, despite their importance, \CGSs{} are not well understood.
To illustrate the lack of a \emph{canonical} definition of a \CGS{},
in \cite{KoppelICFP22}, the authors
used three different \CFG{} generators
on the same program, and obtaining three different \CFGs{}, each
tailored to the objectives of the generator.

Thus, generation of \CFGs{} that present \emph{all relevant} information,
with \emph{minimal} intervention during generation, in a
\emph{correct-by-construction} fashion, is indeed challenging.
In \cite{KoppelICFP22} that authors argue that operational semantics
are not suitable to be used directly for generation of \CFGs{} by demonstrating
that many control flow edges correspond to different halves of the same rule,
while some correspond to none. To address this, the authors translate
the operational semantics to an Abstract Machines (AM) style.


flow graph, it is indeed not the case. Instead, the authors developed an
algorithm to transform the operational semantics into an abstract machine
style. However, this still requires manual specification of abstract
semantics to collapse the inifinite transition system into a finite one.
To this end, the
authors utilize a \emph{value irrelevance} abstration, where all values
are replaced by a single abstract value representing all of them: \startext.
This makes the system finite without direct changes to the semantics.
This approach enables them to canonically define any \CFG{} as a projection
of the transition system an abstracted abstract state machine, where their
treatment of Abstract Machine matches the one in \cite{VanhornArxiv10}.

In this work, we plan to utilize ideas presented in \cite{KoppelICFP22}
in conjunction with a technique called semantics-based compilation (SBC).
Instead of transforming the semantics to an abstract machine, we plan
to utilize SBC to provide a transition system \say{tailored} to the
program itself. To make the transition system itself finite, we plan
to utilize

%But, despite use in tools such as compilers and model checkers,
%there does not exist a \emph{canonical} definition of what CFGs are.
%For example, in \cite{KoppelICFP22}, the authors demonstrates such descrepancies by
%using running different CFG tools on the same code, each resulting in different
%results, to suit specific applications.




%Some, such as \emph{performance improvements}
%for execution and analysis, are not specific to \MediK{}, but vital
%nevertheless. Others, such as \emph{enhancing comprehensibility} of programs
%to non-experts in Computer Science by enabling visual program summaries that only
%present \emph{relevant semantic information} is very benefecial in
%\MediK-centric settings.


%Semantics-based compilation can be considered a generalization of
%established techniques for established techniques for program optimization
%such as partial evaluation of programs \cite{Jones93Book}.
%
%For a given language $L$, let $\llbracket\_\rrbracket_{L}$ be the
%intepreter for L. Say, for given $p \in L$--$\text{Program}$, and inputs
%$\text{in}_1, \text{in}_2$,
%$\text{output} = \llbracket p \rrbracket_{L}\left[\text{in}_1,\text{in}_2\right]$
%if $p$ terminates.
%We can now express partial evaluation of program p, using another
%program $\mix$, called so since performs a mix of both execution and code
%generation as follows:
%  $$\llbracket \llbracket \mix \rrbracket \left[p, \text{in}_1\right] \rrbracket
%  \left[\text{in}_2\right]
%  = \llbracket p \rrbracket \left[\text{in}_1, \text{in}_2\right]$$
%Now, for given program $p$, if $\text{in}_1$ is statically known (at stage 1),
%and $\text{in}_2$ is dynamically known (at stage 2), then, executing the
%entire program in one stage as:
%$$ \llbracket p \rrbracket \left[\text{in}_1, \text{in}_2\right] $$ can be more
%expensive than computing partially evaluating $p$ on $\text{in}_1$,
%i.e. $p_{\text{in}_1} = \llbracket p \rrbracket \left [ \text{in}_1 \right]$ and
%re-utilizing it for phase 2, i.e.
%$\llbracket p \rrbracket \left [\text{in}_1, \text{in}_2 \right] = \llbracket
%p_{\text{in}_1} \rrbracket \left [ \text{in}_2 \right]$
%

%Our experience of implementing pediatric sepsis management in \MediK{}
%revealed the importance of \emph{visual representations} to improve
%comprehensibility of \MediK{} programs to medical domain experts.
%\MediK{} programs structurally resemble flowhcharts by design, but
%if visualized, they resemble existing \BPGs{} found in medical
%literature that \HCPs{} are already familiar with.
%
%We plan to utilize a technique called semantics-based compilation (SBC) to generate
%visual representations.

\subsection{Formal Analysis of Best Practice Guidelines}
To be completed

\paragraph{Responsiveness Verification}
To be completed

\paragraph{Liveness Verification}
To be completed


\paragraph{Generation of Formal Proofs of Execution (optional)}
