\section{Research Plan}

In this section, we discuss challenges we plan to address through this work.

\paragraph{Control Flow Graphs Generation}

Extremely vital to the success of \MediK{}, the the ability
to generate visual representation of \MediK{} programs to aid
comprehensibility to medical domain experts, enabling them to verify
accuracy of encoded medical knowledge. Even though \MediK{} code
structurally resembles paper-based guidelines, said
representations aid comprehensibility for medical
domain experts as the representations resemble their paper-based counterparts,
imparting a sense of familiarity.

Control Flow Graphs (CFGs) form the basis of not only such visual
representations, but other important analyses. For example,
flow-sensitive analyzers can be used to verify that a medical procedure
is performed on both treatment branches.
\CGSs{} form use in applications from compilers to model checkers.
But, despite their importance, \CGSs{} are not well understood.
To illustrate the lack of a \emph{canonical} definition of a \CGS{},
in \cite{KoppelICFP22}, the authors
used three different \CFG{} generators
on the same program, and obtaining three different \CFGs{}, each
tailored to the objectives of the generator.

Thus, generation of \CFGs{} that present \emph{all relevant} information,
with \emph{minimal} intervention during generation, in a
\emph{correct-by-construction} fashion, is indeed challenging.
The authors in \cite{KoppelICFP22} argue that while, intuitively, individual
steps of an operational semantics should correspond to edges of a control
flow graph, it is indeed not the case. Instead, the authors utilize
an algorithm that transforms the operational semantics into an abstract machine
style. However, evaluation even under these semantics would lead to
an infinite transition system, requiring manual specification of abstract
semantics to collapse the system into a finite one. To this end, the
authors utilize a \emph{value irrelevance} abstration, where all values
are replaced by a single abstract value representing all of them: \bigstartext.
This makes the system finite without direct changes to the semantics.


%But, despite use in tools such as compilers and model checkers,
%there does not exist a \emph{canonical} definition of what CFGs are.
%For example, in \cite{KoppelICFP22}, the authors demonstrates such descrepancies by
%using running different CFG tools on the same code, each resulting in different
%results, to suit specific applications.




%Some, such as \emph{performance improvements}
%for execution and analysis, are not specific to \MediK{}, but vital
%nevertheless. Others, such as \emph{enhancing comprehensibility} of programs
%to non-experts in Computer Science by enabling visual program summaries that only
%present \emph{relevant semantic information} is very benefecial in
%\MediK-centric settings.


%Semantics-based compilation can be considered a generalization of
%established techniques for established techniques for program optimization
%such as partial evaluation of programs \cite{Jones93Book}.
%
%For a given language $L$, let $\llbracket\_\rrbracket_{L}$ be the
%intepreter for L. Say, for given $p \in L$--$\text{Program}$, and inputs
%$\text{in}_1, \text{in}_2$,
%$\text{output} = \llbracket p \rrbracket_{L}\left[\text{in}_1,\text{in}_2\right]$
%if $p$ terminates.
%We can now express partial evaluation of program p, using another
%program $\mix$, called so since performs a mix of both execution and code
%generation as follows:
%  $$\llbracket \llbracket \mix \rrbracket \left[p, \text{in}_1\right] \rrbracket
%  \left[\text{in}_2\right]
%  = \llbracket p \rrbracket \left[\text{in}_1, \text{in}_2\right]$$
%Now, for given program $p$, if $\text{in}_1$ is statically known (at stage 1),
%and $\text{in}_2$ is dynamically known (at stage 2), then, executing the
%entire program in one stage as:
%$$ \llbracket p \rrbracket \left[\text{in}_1, \text{in}_2\right] $$ can be more
%expensive than computing partially evaluating $p$ on $\text{in}_1$,
%i.e. $p_{\text{in}_1} = \llbracket p \rrbracket \left [ \text{in}_1 \right]$ and
%re-utilizing it for phase 2, i.e.
%$\llbracket p \rrbracket \left [\text{in}_1, \text{in}_2 \right] = \llbracket
%p_{\text{in}_1} \rrbracket \left [ \text{in}_2 \right]$
%

%Our experience of implementing pediatric sepsis management in \MediK{}
%revealed the importance of \emph{visual representations} to improve
%comprehensibility of \MediK{} programs to medical domain experts.
%\MediK{} programs structurally resemble flowhcharts by design, but
%if visualized, they resemble existing \BPGs{} found in medical
%literature that \HCPs{} are already familiar with.
%
%We plan to utilize a technique called semantics-based compilation (SBC) to generate
%visual representations.

\subsection{Formal Analysis of Best Practice Guidelines}
To be completed

\paragraph{Responsiveness Verification}
To be completed

\paragraph{Liveness Verification}
To be completed


\paragraph{Generation of Formal Proofs of Execution (optional)}
