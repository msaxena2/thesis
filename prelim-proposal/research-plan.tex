\section{Research Plan}

In this section, we discuss challenges we plan to address through this work.

\paragraph{Semantics Based Control Flow Graphs Generation}

Extremely vital to the success of \MediK{}, the the ability
to generate visual representation of \MediK{} programs to aid
comprehensibility to medical domain experts, enabling them to verify
accuracy of encoded medical knowledge. Even though \MediK{} code
structurally resembles paper-based guidelines, said
representations aid comprehensibility for medical
domain experts as the representations resemble their paper-based counterparts,
imparting a sense of familiarity.

Control Flow Graphs (CFGs) form the basis of not only such visual
representations, but other important analyses. For example,
flow-sensitive analyzers can be used to verify that a medical procedure
is performed on both treatment branches.
\CGSs{} form use in applications from compilers to model checkers.
But, despite their importance, \CGSs{} are not well understood.
To illustrate the lack of a \emph{canonical} definition of a \CGS{},
in \cite{KoppelICFP22}, the authors
used three different \CFG{} generators
on the same program, and obtaining three different \CFGs{}, each
tailored to the objectives of the generator.

Thus, generation of \CFGs{} that present \emph{all relevant} information,
with \emph{minimal} intervention during generation, in a
\emph{correct-by-construction} fashion, is indeed challenging.
In \cite{KoppelICFP22} that authors argue that operational semantics
are not suitable to be used directly for generation of \CFGs{} by demonstrating
that many control flow edges correspond to different halves of the same rule,
while some correspond to none. To address this, the authors utilize an algorithm
to construct an Abstract Machines (AM) style semantics from the SOS.

Consider for example, the following SOS rules for assignment:
$$
\infer[AssnCong]
{x := e, \mu\; \leadsto\; x := e^{\prime}, \mu^{\prime}}{e, \mu\; \leadsto\; e^{\prime}\mu^{\prime}}
\quad \quad
\infer[AssnEval]
{x := v,\mu\; \leadsto\; \left(\text{skip}, \mu\left[x \rightarrow v\right]\right)}{}
$$

The authors then automatically generate an AM, written
$\left\langle \left(t, \mu\right) \;\mid\; K\right\rangle$ where $K$ is the
\emph{context} or \emph{continuation} composed of frames of the form $[x\ :=\
(\Box_{t}, \Box_{\mu})]$ indicating holes for an evaluated value and
environment. Thus, the AM rules are:
$$
\left\langle \left( x := e, \mu \right)\;\mid\; k \right\rangle \rightarrow
\left\langle \left( e, \mu \right)\;\mid\; k \circ \left[x := \left(\Box_t,\Box_{\mu}\right) \right]\right\rangle
$$
$$
\left\langle \left( v, \mu \right)\;\mid\; k \right\rangle \rightarrow
\left\langle \left(\text{skip}, \mu\left[x \rightarrow v \right] \right) \;\mid\; k \right\rangle
$$

Next, as it's possible for the AM to have an infinitely-many states, an
abstraction is required to collapse the states and make the transition system
finite. To this end, the authors utilize a \emph{value irrelevant} abstraction
that replaces all values with a single one $\star$ that representing any of
them. With this, the abstract states can be treated as nodes in the CFG.
Thus, program execution with this abstraction will produce a CFG.
For example, consider evaluation of statement $x := y$, under an
infinite number of environments, can lead to an infinite number of
states of the AM.
But, converting all values to $\star$ results in
one-possible execution: $\left\langle \left( x := y, \left[ y \mapsto \star
    \right] \right) \;\mid\; k \right\rangle$
$\rightarrow  \left\langle \left(y, \left[ y \mapsto \star \right] \right) \;\mid\; k \circ \left[ x := \left(\Box_t,\Box_u\right) \right] \right\rangle$
$\rightarrow  \left\langle \left(\star, \left[ y \mapsto \star \right] \right) \;\mid\; k \circ \left[ x := \left(\Box_t,\Box_u\right) \right] \right\rangle$
$\rightarrow  \left\langle \left(\text{skip}, \left[x \mapsto \star, y \mapsto \star \right] \right) \;\mid\; k \right\rangle$

Note that expressions built over $\star$-values can still pose a
challenge. For instance, a statement of the form \inlineimp{while e do s} when
evaluted under an environment $\left[\star \mapsto \star\right]$ requires
handling $\left\langle \left(e, \left[ \star \mapsto \star \right] \right)\;\mid\; k
\right\rangle$, which can be matched by any expression rule. To handle this,
$\left\langle \left(e, \left[ \star \mapsto \star \right] \right)\;\mid\; k \right\rangle$
is over-approximated to $\left \langle \left(\star, \left[ \star \mapsto \star \right] \right)\;\mid\; k \right\rangle$
as evaluating any such $e$ eventually evaluate to $\star$.


%However, this still requires manual specification of abstract
%semantics to collapse the inifinite transition system into a finite one.
%To this end, the
%authors utilize a \emph{value irrelevance} abstration, where all values
%are replaced by a single abstract value representing all of them: \startext.
%This makes the system finite without direct changes to the semantics.
%This approach enables them to canonically define any \CFG{} as a projection
%of the transition system an abstracted abstract state machine, where their
%treatment of Abstract Machine matches the one in \cite{VanhornArxiv10}.

In this work, we plan to utilize ideas presented in \cite{KoppelICFP22}
in conjunction with a technique called semantics-based compilation (SBC).
Instead of transforming the semantics to an abstract machine, we plan
to utilize SBC to provide a transition system \say{tailored} to the
program itself. To make the transition system itself finite, we plan
to utilize

%But, despite use in tools such as compilers and model checkers,
%there does not exist a \emph{canonical} definition of what CFGs are.
%For example, in \cite{KoppelICFP22}, the authors demonstrates such descrepancies by
%using running different CFG tools on the same code, each resulting in different
%results, to suit specific applications.




%Some, such as \emph{performance improvements}
%for execution and analysis, are not specific to \MediK{}, but vital
%nevertheless. Others, such as \emph{enhancing comprehensibility} of programs
%to non-experts in Computer Science by enabling visual program summaries that only
%present \emph{relevant semantic information} is very benefecial in
%\MediK-centric settings.


%Semantics-based compilation can be considered a generalization of
%established techniques for established techniques for program optimization
%such as partial evaluation of programs \cite{Jones93Book}.
%
%For a given language $L$, let $\llbracket\_\rrbracket_{L}$ be the
%intepreter for L. Say, for given $p \in L$--$\text{Program}$, and inputs
%$\text{in}_1, \text{in}_2$,
%$\text{output} = \llbracket p \rrbracket_{L}\left[\text{in}_1,\text{in}_2\right]$
%if $p$ terminates.
%We can now express partial evaluation of program p, using another
%program $\mix$, called so since performs a mix of both execution and code
%generation as follows:
%  $$\llbracket \llbracket \mix \rrbracket \left[p, \text{in}_1\right] \rrbracket
%  \left[\text{in}_2\right]
%  = \llbracket p \rrbracket \left[\text{in}_1, \text{in}_2\right]$$
%Now, for given program $p$, if $\text{in}_1$ is statically known (at stage 1),
%and $\text{in}_2$ is dynamically known (at stage 2), then, executing the
%entire program in one stage as:
%$$ \llbracket p \rrbracket \left[\text{in}_1, \text{in}_2\right] $$ can be more
%expensive than computing partially evaluating $p$ on $\text{in}_1$,
%i.e. $p_{\text{in}_1} = \llbracket p \rrbracket \left [ \text{in}_1 \right]$ and
%re-utilizing it for phase 2, i.e.
%$\llbracket p \rrbracket \left [\text{in}_1, \text{in}_2 \right] = \llbracket
%p_{\text{in}_1} \rrbracket \left [ \text{in}_2 \right]$
%

%Our experience of implementing pediatric sepsis management in \MediK{}
%revealed the importance of \emph{visual representations} to improve
%comprehensibility of \MediK{} programs to medical domain experts.
%\MediK{} programs structurally resemble flowhcharts by design, but
%if visualized, they resemble existing \BPGs{} found in medical
%literature that \HCPs{} are already familiar with.
%
%We plan to utilize a technique called semantics-based compilation (SBC) to generate
%visual representations.

\subsection{Formal Analysis of Best Practice Guidelines}
To be completed

\paragraph{Responsiveness Verification}
To be completed

\paragraph{Liveness Verification}
To be completed


\paragraph{Generation of Formal Proofs of Execution (optional)}
